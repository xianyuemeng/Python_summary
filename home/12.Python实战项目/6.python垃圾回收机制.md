Python垃圾回收机制
===

---

```py
Python垃圾回收机制
    Python的GC模块主要运用了引用计数来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”解决容器对象
可能产生的循环引用的问题。通过分代回收空间以换取时间进一步提高垃圾回收的效率。

引用计数
    原理：当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1，
当对象的引用计数减少为0时，就意味着对象已经再没有被使用过了，可以将其内存释放掉；
    优点：引用计数有一个很大的优点，即实时性，任何内存，一旦没有指向它的引用，就会立即被回收，而其他的垃圾收
集技术必须在某种特殊条件下才能进行无效内存的回收；
    缺点：引用计数机制所带来的维护引用技术的额外操作与Python运行中所进行的内存分配和释放，引用赋值的次数是成
正比的，这显然比其它那些垃圾收集技术所带来的额外操作只是与待回收的内存数量有关的效率要低。同时，引用计数还存
在另外一个很大的问题--循环引用，因为对象之间相互引用，每个对象的引用都不会为0，所以这些对象所占用的内存时钟都
不会被释放掉；


引用计数增加的情况：
    1、对象被创建：x = 3.14；
    2、另外的别名被创建：y=x；
    3、被作为参数传递给函数（新的本地引用）：foobar(x)；
    4、成为容器对象的一个元素：myList = [123, x, 'xyz']
引用计数减少的情况：
    1、一个本地引用离开了其作用范围。入foobar()函数结束时；
    2、对象的别名被显示销毁：del y；
    3、对象的一个别名被赋值给其他对象：x = 123；
    4、对象被从一个窗口对象中移除：myList.remove(x)；
    5、窗口对象本身被销毁：del myList
```


```py
a = []
b = []
a.append(b)
print("b", "-->", b)
print("a", "-->", a)
b.append(a)
print("a", "-->", a)
print("b", "-->", b)
```














