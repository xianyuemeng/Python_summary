面向对象 Object Oriented
===

---

> 面向对象的学习：
> 
> * 面向对象的语法（简单，记忆就可以搞定）
> * 面向对象的思想（稍难，需要一定的理解）


* ## 面向过程和面向对象的区别

    * **面向过程开发，以函数作为基本结构使用**：

        ```py
        吃饭      -> 吃饭的函数
        喝水      -> 喝水函数
        洗衣服    -> 洗衣服的函数
        睡觉      -> 使用充气娃娃的函数
        看电影    -> 买票开电影函数
        ....
        ```

    * **面向对象的开发，以对象作为基本结构使用**： 女朋友( 喂饭功能 喂水功能 洗衣服功能 陪你睡觉功能 陪你看电影功能 .... )

        ```py
        吃饭->调用女盆友的喂饭功能
        喝水->调用女朋友的喂水功能
        洗衣服->调用女朋友的洗衣服功能
        睡觉->调用女朋友的陪睡功能
        ...
        ```
    > 面向对象的开发非常适合大型程序开发，开发速度和后期维护都比过程化开发要好很多。同时，也会降低一点效率。
    >
    > 语言中对象结构的特色：**高内聚，低耦合**。

* ## 面向对象相关的单词：
    ```py
    OO  面向对象

    OOP 面向对象的程序开发

    OOA 面向对象的分析

    OOD 面向对象的设计

    OOI 面向对象的实现

    OOA -> OOD -> OOI == oop 面向对象的实现过程
    ```


# 类和对象

---

```py
人类就是一个类
动物类也是一个类
鸟类就是一个类
女朋友也是一个类
基友也是一个类
瓶子都是一个类
```

**类是一个实物的特征的集合，是抽象的概念。**

```py
打豆豆是一个类
XXOO也是一个类
撩妹也是一个类
开车也是一个类
打人也是一个类
```

> 类也是行为和操作的概念的集合。也是不具体的操作，没有真正操作过。
>
> 类是抽象的概念，仅此而已！

```py
类:	类是抽象的概念
    1. 类是实物特征的集合,是抽象的概念
    2. 类也是行为和操作的概念集合.类只是对行为和操作的想法,并未进行真正的行为和操作
```

**真实发生过得行为就是对象**
**对象一定是具体的或者发生过的事物！**

```py
对象:	对象是具体的特指的实际存在的真实事物
    1. 对象就是具体的存在的,看得见摸得着的特定的某个事物
    2. 对象是真实发生的行为或者操作
```


**由对象总结出类的过程，叫做抽象化**
**由类制作出对象的过程，叫做实例化**

```py
类和对象的关系:
    1. 类是由多个对象归纳总结而来的,类是一种概念,包含了所有的对象  		对象---抽象化--->类
    2. 对象是由类具体操作或者实现而来的,是真实存在的,特质的某个事物		类---实例化--->对象
```

---

# 类的声明书写

    ```py
    class 类名:
        # 成员属性
        
        # 成员方法

    '''
    1. 类的声明必须使用class关键字进行声明
    2. 类的命名必须使用大驼峰命名规则
    3. 类中只能书写成员属性(变量)和成员方法(函数)
        成员属性(变量)必须要有初始值,为空可用None
        成员方法(函数)参照函数的声明方式即可
    ```
* ### 类的组成
    * 类中只有2种内容：**成员属性**和**成员方法**
        ```py
        成员属性:
            用于描述类的特征的变量就是成员属性

        成员方法：
            用于描述类的功能的函数就是成员方法
        ```

* ### 类的书写规则
    ```py
    1.必须使用class关键字来声明一个类
    2.类的名称需要符合驼峰命名法（规范）
    3.类中只能存在2种内容，成员属性和成员方法，除此之外，所有的代码都禁止出现！
    4.声明成员属性时，所有成员属性必须有值，如果没值会报错！，推荐使用None等值代替
    5.成员方法只需要按照函数的规则声明即可
    ```

* ### 实例化对象

    ```py
    1. 实例化格式
        对象名 = 类名()
    2. 类的类型
        print(type(类名))  	---> 类的类型就是type
        <class 'type'>
    3. 类的值
        print(类名) 			---> 类的值就是类自身
        <class '_main_'. 类名 >
    4. 对象的类型
        print(type(对象名))    ---> 对象的类型就是类
        <class '_main_'. 类名 >
    5. 对象的值
        print(对象名)			---> 对象的值就是对象本身
        <'_main_'.类名 object at 内存...>
    ```

* ### 检测类和对象的成员

    ```py
    检测类成员

        类名.__dict__

    检测对象成员

        对象.__dict__
    ```

* ### 类和对象的成员操作(增,删,改,查)

    * #### 类的成员操作(成员属性 和 成员方法)
        ```py
        1. 增 (向类中添加新的成员)
            类名.新成员属性名 = 值
            类名.新成员方法名 = lambda 表达式	or  类名.新的成员方法名 = 之前定义好的函数
        2. 删 (删除类中的成员)
            del 类名.成员属性
            del 类名.成员方法
        3. 改 (修改类中的成员)
            类名.成员属性名 = 新的值
            类名.成员方法名 = 新的lambda表达式	or	类名.成员方法名 = 之前定义好的新函数
        4. 查(访问类中的成员)
            类名.成员属性名
            类名.成员方法名() ---- 所有方法都可以通过类来调用,无论是绑定类方法还是非绑定类方法
        ```

    * #### 对象的成员操作(成员属性 和 成员方法)
        ```py
        1. 增 (向对象中添加新的成员)
            对象名.新的成员属性名 = 值
            对象名.新的成员方法名 = lambda 表达式  or  对象名.新的成员方法名 = 之前定义好的函数
        2. 删 (删除对象中的成员)
            del 对象名.成员属性名
            del 对象名.成员方法名
        3. 改 (修改对象中的成员)
            对象名.成员属性名 = 新的值
            对象名.成员方法名 = 新的lambda表达式  or  对象名.成员方法名 = 之前定义好的函数
        4. 查 (访问类中成员)
            对象名.成员属性名
            对象名.成员方法名() ---- 通过对象,只能调用类中定义的带有形参self的成员方法.因为对象在调用类的函数的时候，默认会将对象自身当做实参传入成员方法中,需要一个形参来接收传入的对象本身!!!
        对象可以使用的成员方法 --- 非绑定类方法
        ```

* ### 关于self

    * **他不是关键字，是一个随意书写的字符串而已**
      
        ```py
        1. self不是关键字,只是在类的方法中的一个形参,可以用其他字母代替但是不允许为空
        2. 类的成员方法有self形参,则为非绑定类方法.
            非绑定类方法,类调用需要传入任一实参给self
            非绑定类方法,对象调用默认会将对象自身作为实参传给self,所以直接调用即可不用加其他参数
        3. 类的成员方法没有self形参,则为绑定类方法
            绑定类方法,就只能通过类或子类(反正只有类能用)来调用
            绑定类方法,当前类的对象或子对象都不能用!! (没有形参对象调用的时候传入的实参没人接收啊!!)
        4. self 决定的就是类中的方法对象能不能用! 有self对象就可以用,没有self对象就不能用!
        ```
---

# 面向对象的三大特性

> 面向对象都具有三大特性：**封装**，**继承** 和 **多态**

---
* ### 封装

    封装就是对类和对象的成员访问进行限制，设定可以访问的方式和不可以访问的方式。

    * **封装的三个级别**
        ```py
        私有化封装      -> private  英文单词而已不是关键字
        受保护的封装     -> protected  英文单词而已不是关键字
        公共的封装      -> public 英文单词而不是关键字
        ```

    * **检测封装的三个位置：**
        ```py
        类中/对象中
        类外部/对象外部
        子类中
        ```

* #### 私有化封装 private

    私有化封装是最高级别的封装。私有化封装之后的成员,只能在类中/对象中访问，类的外部，子类中都不可以访问到。
        
    * 私有化封装的格式
        ```py 
        在类中成员属性或者成员方法前面加 __ 双下划线

        成员属性名 ---私有化----> __成员属性名
        成员方法名 ---私有化----> __成员方法名
        ```

    * 私有化封装的权限
        ```py 
        当前类内/对象内	    可访问    类名/对象名.__成员属性名 或者 类名/对象名.__成员方法名()
        子类内/子类外	    不可以访问!
        类外/对象外	        不可以访问
        ```

    * python中私有化的实质(namemanling--改名策略)
        ```py 
        __成员属性名---> python会在系统中改名为 _类名__成员属性名  在类外/对象外 类名/对象名._类名__成员属性名
        __成员方法名---> python会在系统中改名为 _类名__成员方法名  在类外/对象外 类名/对象名._类名__成员方法名
        ```


    * >注意：在python中实现的封装操作，不是通过权限限制而是通过改名(name mangling 改名策略)实现的，名字变了找不到而已。
        >
        >可以通过 对象.类名 __方法或类名.类名 __方法名访问到（但禁止这么干）

* #### 受保护的封装 protected

    受保护的封装是一定级别的封装，封装之后，只有部分位置可以访问（类和子类），部分位置（类外）不可以访问。

    * 受保护的封装的权限    
        ```py
        当前类内/对象内		可访问		类名/对象名._成员属性名 or 类名/对象名._成员方法名()
        子类内/子对象内		可访问		子类名/子对象名._成员属性名 or 子类名/子对象名._成员方法名()
        类外/子类外	    不可访问   (逻辑上是不可以的,但是python中未实现该功能)
        ```

    * 受保护的封装格式
        ```py
        在成员属性名或者成员方法名前面加上 _ 下划线

        成员属性名 ---受保护的封装---> _成员属性名
        成员方法名 ---受保护的封装---> _成员方法名
        ```

* #### 公共的封装 public

    * 公开的封装的权限
        ```py
        当前类内/对象内		可访问		类名/对象名.成员属性名 or 类名/对象名.成员方法名()
        子类内/子对象内		可访问		子类名/子对象名.成员属性名 or 子类名/子对象名.成员方法名()
        类外/对象外	    可访问	  类名/对象名.成员属性名 or 类名/对象名.成员方法名()
        ```

---

* ### 继承

    > 继承就是可以获取另外一个类中的成员属性和成员方法。(并非所有成员)
    >
    > **作用**：继承的作用是增加代码的复用性，节省不必要的重复代码，提高开发效率，同时可以设置类之间的关系。


    * **父类和子类**
        ```py
        父类: 被继承的类,叫做父类,也叫超类或者基类
        子类: 继承别人类的类,叫做子类,也叫派生类 
        ```

    * **继承的格式**
        ```py
        class 父类名:
            pass

        # 继承操作的关键步骤
        class 子类名(父类名):  
            pass
        ```

    * **继承的特征**
        ```py
        1.所有类都是继承自object类（object类对应的对象就是object对象，也是万物皆对象）
        2.子类继承父类则可以访问父类的所有成员。（私有成员除外）
        3.子类继承父类并不会将父类的所有成员复制到子类当中去，访问父类成员是间接通过父类来访问的，
        4.子类可以具有自己独有的属性和方法
        5.子类可以重载父类中的方法，只需要设置和父类指定成员相同的名称即可实现重载，重载之后的成员，子类只会访问当前类中的成员，而不会调用父类中同名的成员
        6.子类中如果重载父类的方法，并且还想将重载的父类方法借调过来使用，可以在重载的方法中使用如下方法:

            [父类名.方法()](适合类)  或者  [super().方法()](适合对象)
        ```

* ### 单继承和多继承

    > 单继承：每个类只能继承一个类的方式称为单继承。
    >
    >多继承：每个类可以同时继承多个类的方式称为多继承。
    >
    >python属于多继承语言！但是一般不用

    ```py
    单继承: 每个类只继承一个类的方式
		儿子 ---继承---> 爸爸 ---继承--->爷爷---继承--->太爷爷
		儿子具有爸爸,爷爷,太爷爷的所有未私有化的成员属性和方法
    多继承: 一类继承多个类的方法,具有继承的所有类的未私有化的成员属性和成员方法
    ```
    * **单继承格式**
        ```py
        class Father:
            pass
        
        class Son(Father):
            pass
        ```

    * **多继承格式**
        ```py
        class Teacher:
            pass

        class Classmate:
            pass

        class Father:
            pass
            
        class Mother:
            pass
            
        class child(Teacher,Classmate,Father,Monther):
            pass

        多继承之后，子类就具备了所有父类的成员（私有成员除外）

        多个父类具有相同的成员时，子类继承[继承列表]中第一个类的方法
        ```

    * **菱形继承/钻石继承**

        ```py
        class A:
            pass

        class B(A):
            pass

        class C(A):
            pass

        class D(B,C):
            pass

          A
         / \
        B   C
         \ /
          D
        ```
        ```py
        菱形继承存在的问题


        class Animal:
            def say(self):
                print('动物开始叫')
                print('动物停止叫')

        class Human(Animal):
            def say(self):
                print('人类开始说话')
                Animal.say(self)
                print('人类停止说话')
                
        class Bird(Animal):
            def say(self):
                print('鸟类开始叫')
                Animal.say(self)
                print('鸟类停止叫')
                
        class FlyMan(Human,Bird):
            def say(self):
                print('鸟人开始说话')
                Human.say(self)
                Bird.say(self)
                print('鸟人停止说话')

        FlyMan.say(1)

        调用了FlyMan中的say方法的时候,Human和Bird中的Animal方法会执行两次,这并不符合逻辑.如果是计数器或者之间的话,就会重复计数.在菱形继承中,可以使用super()来避免产生这样的错误!!

        如果BC类同时继承了A类，D类又继承了BC两个类的情况下(菱形继承)，
        在调用BC中某个同名方法(该方法都继承自A类)时会导致继承自A类的该方法被多次调用。产生逻辑问题！
        
        所以python使用 super() 类来解决了多继承的菱形继承问题
        ```

    * **MRO列表和 super()**

        * MRO列表

            - 存有类的继承信息的列表
            - 子类永远在父类之前
            - 列表的顺序按照继承格式()中的顺序

        * super()

            - super()不是一个关键字也不是一个函数,而是一个类
            - super()的作用是寻找mro列表中的下一个元素,继承关系中上一个类! 子类对象调用父类方法可使用 super().方法名() 无需self
            - super() 可以避免菱形继承导致的多次调用底层父类同一个方法的情况. 因为mro列表实际上已经把原来菱形继承改成了单继承[D,B,C,A]
            * 格式
                `super().方法()      #python3的格式`

            ```py
            class Animal:
                def say(self):
                    print('动物开始叫')
                    print('动物停止叫')

            class Human(Animal):
                def say(self):
                    print('人类开始说话')
                    super().say()
                    print('人类停止说话')
                    
            class Bird(Animal):
                def say(self):
                    print('鸟类开始叫')
                    super().say()
                    print('鸟类停止叫')
                    
            class FlyMan(Human,Bird):
                def say(self):
                    print('鸟人开始说话')
                    super().say()
                    print('鸟人停止说话')

            fm = FlyMan()
            fm.say()
            ```

    * **多继承按需操作，在没有必要的时候避免强行使用!**

---

* ### mixin 设计模式

    > 该设计模式的主要作用是采用多继承方式，进行类的扩展。

    * **优点**
        ```py
        1.mixin可以在对类不做任何修改的情况下，扩展类的功能（添加父类）
        2.可以方便的组织和维护各种不同组件的划分。
        3.可以根据需要任意调整
        4.可以避免创建更多的类，也可以避免继承导致的混乱
        ```
        ```py
        #水果类
        class Fruit:
            pass

        #礼物类和非礼物类
        class Gift:
            pass
        class NotGift:
            pass

        #南方北方类
        class South:
            pass
        class North:
            pass

        #爽和不爽的苹果
        class Cool:
            pass
        class NotCool:
            pass

        #真实水果类
        class Apple(Fruit,Gift,North,NotCool):
            pass

        class Pear(Fruit,NotGift,North,NotCool):
            pass

        class Banana(Fruit,NotGift,North,Cool):
            pass

        class Orange(Fruit,Gift,South,NotCool)
        ```

---

* ### 多态

    > 多态就是多种状态!!!   就是一个类，根据不同的情况，相同的方法产生不同的结果。

    * **多态示例**
        ```py
        # 导入抽象类模块
        import abc

        # 1. 定义抽象类,作为之后开发其他相关类的规范
        class Animal(metaclass = abc.ABCMeta):
            
            # 定义非绑定类的抽象类方法
            @abc.abstractmethod
            def saniao(self):
                pass
                
            # 定义非绑定类的抽象类方法
            @abc.abstractmethod
            def lashi(self):
                pass
            
            # 定义非绑定类的抽象类方法
            @abc.abstractmethod
            def jiao(self):
                pass
        ```

    * **在抽象类规范的基础上,定义其他的类继承抽象类,并实现抽象类所有方法**
        ```py
        # 定义猫类
        class Cat(Animal):
            def saniao(self):
                print('猫咪蹲着撒尿')
            def lashi(self):
                print('猫咪蹲着拉屎')
            def jiao(self):
                print('猫咪喵喵叫~')

        # 定义狗类
        class Dog(Animal):
            def saniao(self):
                print('狗狗抬起腿撒尿')
            def lashi(self):
                print('狗狗蹲着拉屎')
            def jiao(self);
                print('狗狗汪汪汪叫')

        # 定义鸡类
        class Chick(Animal):
            def saniao(self):
                print('小鸡站着尿尿')
            def lashi(self):
                print('小鸡站着拉屎')
            def jiao(self):
                print('小鸡咯咯咯叫')
        ```

    * **将类实例化做出对象   之后将对象作为参数传入行为类中!**
        ```py
        cat = Cat()
        dog = Dog()
        chick = Chick()
        ```

    * **定义行为类,用来接收不同的类做出来的对象,根据不同的对象,分配不同的方法**
        ```py
        class Action:
            def __init__(self,obj)
                self.animal = obj

            def saniao(self):
                self.animal.saniao()
            
            def lashi(self):
                self.animal.lashi()
            
            def jiao(self):
                self.animal.jiao()
        ```

    * **将不同的类做出来的对象传入行为类中作为参数,再调用方法**
        ```py
        action1 = Action(cat)
        action1.saniao()
        action1.lashi()
        action1.jiao()

        action2 = Action(dog)
        action2.saniao()
        action2.lashi()
        action2.jiao()

        action3 = Action(chick)
        action3.saniao()
        action3.lashi()
        action3.jiao()
        ```